# -*- coding: utf-8 -*-
"""2018SEAB Sample OOP - Stack and Queue - Coursemology.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EpOK6KgMJkW6Ju-eBSKWtEUtnPjIxokG

# 2018 SEAB Sample OOP Question - Stack and Queue

A programmer is writing a program to manipulate different data structures using object-oriented programming (OOP).

The super class, **DataStructure**, will store the following data:

- a list of the data items
- head pointer, pointing to the first element in the list
- tail pointer, pointing to the last element in the list

This class has one method to display all the current contents in the structure, in the order they are stored in the list.

A stack and a linear queue are implemented using the super class.

The subclass **Stack** has the following methods:

- *push(value)* appends the parameter value to the stack
- *pop()* returns and remove the next value in the stack
- *display()* method should display the stack in reverse order (e.g. the most recently added element first) and should override the DataStructure display() method

The subclass **Queue** has the following methods:

- *addToQueue(value)* appends the parameter value to the queue
- *remove()* removes the next value in the queue
- *display()* method should display the queue contents in order (e.g. the earliest added element first) and should override the DataStructure display() method

Each method updates its appropriate pointers, and produces suitable errors (or returns different values) to indicate if the actions are not possible e.g. if the structure is empty.

##**Task 3.1**

Write program code for the superclass **DataStructure**.

**Evidence 3.1**
"""

class DataStructure:
    def __init__(self):
        self.data = []
        self.head = -1
        self.tail = -1

    def get_head(self):
        return self.head

    def get_tail(self):
        return self.tail

    def set_head(self, new_head):
        self.head = new_head

    def set_tail(self, new_tail):
        self.tail = new_tail

    def counter(self):
        return len(self.data)

    def display(self):
        print('head:', self.head)
        print('tail:', self.tail)
        
        for i in range(len(self.data)):
            print(self.data[i])

# test superclass DataStructure



ds = DataStructure()










"""##**Task 3.2**

Write program code for the subclass **Stack**.

Use appropriate inheritance and polymorphism in your design

**Evidence 3.2**
"""

class Stack(DataStructure):
    def __init__(self):
        super().__init__()

    def push(self, value):
        self.data.append(value)
        self.head = 0
        self.tail += 1

    def pop(self):
        if self.data == []:
            return None

        elif len(self.data) == 1:
            self.tail = -1
            self.head = -1
            return self.data.pop()

        else:
            self.tail -= 1
            return self.data.pop()

    def display(self):
        print('<<< STACK <<<')
        print()
        print('head -> ' + str(self.data) + ' <- tail')
        print()

    

# test subclass Stack
# Do not remove the following:
s1 = Stack()
s1.push(5)
s1.push(8)
s1.push(22)
# print(s.display())

# print(s1.data)  #[5, 8, 22]  
# print(s1.head)  #0   
# print(s1.tail)  #2   
# print(s1.pop()) #22  
# print(s1.data)  #[5, 8]  
# print(s1.head)  #0   
# print(s1.tail)  #1   
# print(s1.pop()) #8   
# print(s1.pop()) #5   
# print(s1.head)  #-1  
# print(s1.tail)  #-1









"""##**Task 3.3**

Write program code for the subclass **Queue**.

Use appropriate inheritance and polymorphism in your design.

**Evidence 3.3**
"""

class Queue(DataStructure):
    def __init__(self):
        super().__init__()

    def addToQueue(self, value):
        self.head = 0
        self.tail += 1
        self.data.append(value)

    def remove(self):
        if self.data == []:
            return None

        elif len(self.data) == 1:
            self.tail = -1
            self.head = -1

        else:
            self.tail -= 1

        return self.data.pop(0)

    def display(self):
        print('<<< QUEUE <<<')
        print()
        print('head -> ' + str(self.data) + ' <- tail')
        print()

#  test subclass Queue
q1 = Queue()
q1.addToQueue(5)
q1.addToQueue(8)
q1.addToQueue(22)

# print(q1.display())

# print(q1.data)  #[5, 8, 22]  
# print(q1.head)  #0   
# print(q1.tail)  #2   
# print(q1.remove())  #5   
# print(q1.data)  #[8, 22] 
# print(q1.remove())  #8   
# print(q1.remove())  #22  
# print(q1.head)  #-1  
# print(q1.tail)  #-1













"""##**Task 3.4**

The files **TASK3stack.txt** and **TASK3queue.txt** store data to test your program.

Write program code to:

- create a new stack and add the data in the file **TASK3stack.txt** to the stack
- create a new queue and add the data in the file **TASK3queue.tx**t to the queue
- output the current contents of both the stack and queue
- remove and output two items from both the stack and queue
- output the contents of both the stack and queue after the removal of the items

All outputs should have appropriate messages to indicate what they are showing.

**Evidence 3.4**
"""

# Must upload "TASK3stack.txt" and "TASK3queue.txt" to Google.Colaboratory

# create a new stack and add the data in the file TASK3stack.txt to the stack
s = Stack()
f = open('TASK3stack.txt', 'r').read().split()
# print(f)
for ele in f:
    s.push(ele)


# create a new queue and add the data in the file TASK3queue.txt to the queue

q = Queue()
f = open('TASK3queue.txt', 'r').read().split()
for ele in f:
    q.addToQueue(ele)


# output the current contents of both the Stack and Queue
print(s.display())
print(q.display())

# remove and output two items from both the Stack and Queue
# stack
print(s.pop())
print(s.pop())

#queue
print(q.remove())
print(q.remove())


# output the contents of both the Stack and Queue after the removal of the items.
print(s.display())
print(q.display())