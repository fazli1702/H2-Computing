# -*- coding: utf-8 -*-
"""2018SEAB Sample OOP - Stack and Queue - Coursemology.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EpOK6KgMJkW6Ju-eBSKWtEUtnPjIxokG

# 2018 SEAB Sample OOP Question - Stack and Queue

A programmer is writing a program to manipulate different data structures using object-oriented programming (OOP).



The super class, **DataStructure**, will store the following data:

- a list of the data items
- head pointer, pointing to the first element in the list
- tail pointer, pointing to the last element in the list

This class has one method to display all the current contents in the structure, in the order they are stored in the list.



A stack and a linear queue are implemented using the super class.

The subclass **Stack** has the following methods:

- *push(value)* appends the parameter value to the stack
- *pop()* returns and remove the next value in the stack
- *display()* method should display the stack in reverse order (e.g. the most recently added element first) and should override the DataStructure display() method

The subclass **Queue** has the following methods:

- *addToQueue(value)* appends the parameter value to the queue
- *remove()* removes the next value in the queue
- *display()* method should display the queue contents in order (e.g. the earliest added element first) and should override the DataStructure display() method

Each method updates its appropriate pointers, and produces suitable errors (or returns different values) to indicate if the actions are not possible e.g. if the structure is empty.




##**Task 3.1**

Write program code for the superclass **DataStructure**.

**Evidence 3.1**
"""

class DataStructure:
    def __init__(self):
        self.data = []
        self.head = -1
        self.tail = -1

    def display(self):
        print('head:', self.head)
        print('tail:', self.tail)
        
        for i in range(len(self.data)):
            print(self.data[i])
    
# test superclass DataStructure
ds = DataStructure()










"""##**Task 3.2**

Write program code for the subclass **Stack**.

Use appropriate inheritance and polymorphism in your design

**Evidence 3.2**
"""

class Stack(DataStructure):
    def __init__(self):
        super().__init__()

    def push(self, value):
        self.head = 0
        self.tail += 1
        self.data.append(value)

    def pop(self):
        if self.data == []:
            print('No data to pop')
        elif len(self.data) == 1:
            removed = self.data[self.head]
            self.tail = -1
            self.head = -1
            self.data = []
            return removed
        else:
            removed = self.data[self.tail]
            self.tail -= 1
            self.data = self.data[self.head : self.tail+1]
            return removed
        

    def display(self):
        super().display()



        

# test subclass Stack
s = Stack()
s.push(5)
s.push(8)
s.push(22)











"""##**Task 3.3**

Write program code for the subclass **Queue**.

Use appropriate inheritance and polymorphism in your design.

**Evidence 3.3**
"""

class Queue(DataStructure):
    def __init__(self):
        super().__init__()

    def addToQueue(self, value):
        self.data.append(value)
        if self.head == -1:
            self.head = 0
            self.tail = 0
        else:
            self.tail += 1

    def remove(self):
        if self.data == []:
            return None
        elif len(self.data) == 1:
            removed = self.data[0]
            self.head = -1
            self.tail = -1
            self.data = []
            return removed
        else:
            removed = self.data[0]
            self.head += 1
            self.data = self.data[self.head:]
            return removed

    def display(self):
        super().display()

#  test subclass Queue


q = Queue()
q.addToQueue(5)
q.addToQueue(8)
q.addToQueue(22)












"""##**Task 3.4**

The files **TASK3stack.txt** and **TASK3queue.txt** store data to test your program.

Write program code to:

- create a new stack and add the data in the file **TASK3stack.txt** to the stack
- create a new queue and add the data in the file **TASK3queue.tx**t to the queue
- output the current contents of both the stack and queue
- remove and output two items from both the stack and queue
- output the contents of both the stack and queue after the removal of the items

All outputs should have appropriate messages to indicate what they are showing.

**Evidence 3.4**
"""

# Must upload "TASK3stack.txt" and "TASK3queue.txt" to Google.Colaboratory

# create a new stack and add the data in the file TASK3stack.txt to the stack





# create a new queue and add the data in the file TASK3queue.txt to the queue





# output the current contents of both the Stack and Queue

# remove and output two items from both the Stack and Queue





# output the contents of both the Stack and Queue after the removal of the items.
